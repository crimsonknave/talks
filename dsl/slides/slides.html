<section>
  <h1>Writing a 'DSL' in ruby</h1>
  Joseph Henrich
</section>
<section>
  <h3>Disclaimer</h3>
  This is not a talk about how to write a real DSL (read: actual language spec ala HTML/Regex), instead it's a talk about how to write language specific to your domain.
</section>
<section>
  <section>
    <h1>Types</h1>
    <ul>
      <li>Config Blocks</li>
      <li>class keywords</li>
      <li>other blocks</li>
    </ul>
  </section>
  <section>
    <h1>config blocks</h1>
    <pre><code class="ruby">MyGem.configure do |config|
  config.be_awesome
  config.thingy = 'I am a thing'
end</code></pre>
  </section>
  <section>
    <h1>class keywords</h1>
    <pre><code class="ruby">class Model &lt; ActiveRecord::Model
  has_many :things
  belongs_to :owner
end</code></pre>
  </section>
  <section>
    <h1>other blocks</h1>
    <pre><code class="ruby"># Sinatra
get '/hi' do
  "Hello World!"
end</code></pre>
  </section>
</section>
<section>
  <section>
    <h1>how</h1>
  </section>
  <section>
    <h1>metaprogramming</h1>
    Metaprogramming is the most important piece of writing some language specific code. Heavy use of define method lets you create methods on the fly based on how your code is used.
  </section>
  <section>
    <h1>class methods</h1>
    By using class methods you can define what appear to be keywords.
  </section>
  <section>
    <h1>Optional Parameters</h1>
    If you want your 'dsl' to look more 'natural' then consider using optional prams instead of an equal sign.
    <pre><code class="ruby">Car.config do
  color 'blue'
  year 2015
end</code></pre>
  </section>
  <section>
    <h1>Before and After</h1>
    A common pattern to manage lifecycle states is to have allow for before and after blocks. These blocks allow for greater control if you need to cleanup something but need it to be done outside of the normal window.
  </section>
</section>
<section>
  <section>
    <h1>Examples</h1>
  </section>
  <section>
    <h1>Cot</h1>
    <pre><code class="ruby">class WrappedObject &lt; Cot::Frame
  property :id
  property :name, searchable: true
  proprety :company_name, from: :companyName
  property :item do
    from :itemValue
    value do |params|
      NestedClass.new params.merge parent_id: id
    end
  end
  property :blank do
    missing do
      "Item #{id}"
    end
  end
end</code></pre>
  </section>
  <section>
    <h1>Cot</h1>
    <pre><code class="ruby">def self.property(name, args = {}, &amp;block)
  prop = Property.new args
  prop.instance_eval(&amp;block) if block

  set_blocks(name, prop)
  set_mappings(name, prop)
  @primary_key = name if prop.primary?

  define_method name do
    self[name]
  end
  define_method "#{name}=" do |value|
    self[name] = value
  end
  define_attribute_method name
end</code></pre>
  </section>
  <section>
    <h1>Jenkins Pipeline Builder</h1>
    <pre><code class="ruby">builder do
  name :shell_command
  plugin_id 'builtin'
  description 'Lets you run shell commands as a build step.'
  jenkins_name 'Execute shell'
  announced false

  xml do |param|
    send('hudson.tasks.Shell') do
      command param
    end
  end
end</code></pre>
  </section>
  <section>
    <h3>Jenkins Pipeline Builder - Extension Sets</h3>
    <pre><code class="ruby">[:builder, :trigger, :publisher].each do |type, path|
  define_method type do |&amp;block|
    set = JenkinsPipelineBuilder::ExtensionSet.new
    set.instance_eval(&amp;block)
    set.blocks.each do |version, settings|
      set.add_extension type, version, settings, path
    end
    unless set.valid?
      set.report_invalid_status
      return false
    end
    versions = set.extensions.map(&amp;:min_version)
    puts "Successfully registered #{set.name} for versions #{versions}" if set.announced
  end
end</code></pre>
  </section>
  <section>
    <h3>Jenkins Pipeline Builder - Extension Blocks</h3>
  </section>
</section>
